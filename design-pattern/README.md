# 设计模式

可以分为三类：
- Creational 创建型模式
- Structural 结构型模式
- Behavioral 行为型模式

----
## 创建型模式
对类的实例化过程进行了抽象，能够将软件模式中对象的创建和对象的使用分离，使整个系统的设计更加符合单一职责原则。
创建型模式在创建什么（ WHAT ），由谁创建（ WHO ），何时创建（ WHEN ) 等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到了使整个系统独立的目的。

### Simple Factory
简单工厂模式，又称为静态工厂方法模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其它类的实例，被创建的实例通常都具有共同的父类。

生成实例对象，对于调用方屏蔽具体的实例化过程。

### Factory Method
工厂方法模式又称为工厂模式，也叫 virtual constructor 虚拟构造器模式或者 polymorphic factory 多态工厂模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成。

将实例化委托给子类。

when to use ? 当一个类不知道他可能需要什么样的子类时。

### Abstract Factory
抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

when to use ? 当存在相互关联的依赖关系时，涉及非简单的创建逻辑。

### Builder
建造者模式，将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。比如一份 KFC 套餐可能由主食、小吃、饮料组成。

when to use ？当可能存在几种类型的对象并避免构造函数伸缩时，创建是多步过程。

### Singleton
单例模式。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

### Prototype
通过克隆一个已存在的对象创建新的对象实例。

----
## 结构型模式
结构型模式描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

### Adapter
适配器模式。将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

### Bridge
桥接模式。将抽象部分与它的实现部分分离，使它们都可以独立地变化。又称为柄体(Handle and Body)模式或接口(Interface)模式。

### Composite
复合模式。以统一的方式处理单个对象。

### Decorator
装饰模式。动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。

### Facada
外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

### Flyweight
享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

### Proxy
代理模式。给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

----
## 行为型模式
行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

### Chain of Responsibility
责任链模式。它构建了一个链式对象。请求从一端进入并继续从一个对象到另一个对象，直到找到合适的处理程序。

### Command
命令模式。将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化，这种模式背后的关键思想是提供将客户端与接收器分离的方法。

### Iterator
迭代模式。它提供了一种访问对象元素而不暴露底层表示的方法。

### Mediator
中间人模式。用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### Memento
备忘录模式。关于以稍后可以以平滑方式恢复的方式捕获和存储对象的当前状态。

### Observer
观察者模式。定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

### Visitor
游客模式。访客模式允许您向对象添加更多操作，而无需修改它们。

### Strategy
策略模式。定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式是让算法独立于使用它的客户而变化，也称为政策模式（policy）。策略模式允许您根据情况切换算法或策略。

### State
状态模式。允许一个对象在其内部状态改变时改变它的行为。

### Template Method
模板方法模式。模板方法定义了如何执行某个算法的框架，但是将这些步骤的实现推迟到子类。